1) O(1): Time complexity of a function (or set of statements) is considered as O(1) if it doesn't contain loop, recursion, and call to any other non-constant time function. 
 

   // set of non-recursive and non-loop statements

For example, swap() function has O(1) time complexity. 
A loop or recursion that runs a constant number of times is also considered as O(1). For example, the following loop is O(1). 
 

   // Here c is a constant   
   for (int i = 1; i <= c; i++) {  
        // some O(1) expressions
   }

2) O(n): Time Complexity of a loop is considered as O(n) if the loop variables are incremented/decremented by a constant amount. For recursive call in recursive function, the time complexity is considered as O(n). For example following functions have O(n) time complexity. 
 

   // Here c is a positive integer constant   
   for (int i = 1; i <= n; i += c) {  
        // some O(1) expressions
   }

   for (int i = n; i > 0; i -= c) {
        // some O(1) expressions
   }
 

//Recursive function
void recurse(n)
{
    if(n==0)
        return;
    else{
        // some O(1) expressions
    }
    recurse(n-1);
}

3) O(nc): Time complexity of nested loops is equal to the number of times the innermost statement is executed. For example, the following sample loops have O(n2) time complexity 
 

  
   for (int i = 1; i <=n; i += c) {
       for (int j = 1; j <=n; j += c) {
          // some O(1) expressions
       }
   }

   for (int i = n; i > 0; i -= c) {
       for (int j = i+1; j <=n; j += c) {
          // some O(1) expressions
   }

For example, Selection sort and Insertion Sort have O(n2) time complexity. 


4) O(Logn) Time Complexity of a loop is considered as O(Logn) if the loop variables are divided/multiplied by a constant amount. 
 

   for (int i = 1; i <=n; i *= c) {
       // some O(1) expressions
   }
   for (int i = n; i > 0; i /= c) {
       // some O(1) expressions
   }

For example, Binary Search(refer iterative implementation) has O(Logn) time complexity. Let us see mathematically how it is O(Log n). The series that we get in the first loop is 1, c, c2, c3, ... ck. If we put k equals to Logcn, we get cLogcn which is n. 


5) O(LogLogn) Time Complexity of a loop is considered as O(LogLogn) if the loop variables are reduced/increased exponentially by a constant amount. 
 

   // Here c is a constant greater than 1   
   for (int i = 2; i <=n; i = pow(i, c)) { 
       // some O(1) expressions
   }
   //Here fun is sqrt or cuberoot or any other constant root
   for (int i = n; i > 1; i = fun(i)) { 
       // some O(1) expressions
   }



Algorithm	      Best Case	Average Case	Worst Case
Selection Sort	 O(n^2)   	O(n^2)	O(n^2)
Bubble Sort	      O(n)	    O(n^2)	O(n^2)
Insertion Sort	  O(n)	   O(n^2)	  O(n^2)
Tree Sort	       O(nlogn)	O(nlogn)	O(n^2)
Radix Sort	      O(dn)	    O(dn)	  O(dn)
Merge Sort	    O(nlogn)	O(nlogn)	O(nlogn)
Heap Sort	      O(nlogn)	O(nlogn)	O(nlogn)
Quick Sort	    O(nlogn)	O(nlogn)	O(n^2)
Bucket Sort	     O(n+k)	   O(n+k)	  O(n^2)
Counting Sort	   O(n+k)	   O(n+k)	  O(n+k)
 

